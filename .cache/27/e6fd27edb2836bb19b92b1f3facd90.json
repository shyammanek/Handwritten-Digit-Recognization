{"id":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/lrn_grad_gpu.js","dependencies":[{"name":"E:\\htr-final\\node_modules\\@tensorflow\\tfjs-core\\dist\\kernels\\webgl\\lrn_grad_gpu.js.map","includedInParent":true,"mtime":499162500000},{"name":"E:\\htr-final\\package.json","includedInParent":true,"mtime":1603094551417},{"name":"E:\\htr-final\\.babelrc","includedInParent":true,"mtime":1603022514142},{"name":"E:\\htr-final\\node_modules\\@tensorflow\\tfjs-core\\package.json","includedInParent":true,"mtime":1603088140582}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar LRNGradProgram = (function () {\n    function LRNGradProgram(inputShape, depthRadius, bias, alpha, beta) {\n        this.variableNames = ['inputImage', 'outputImage', 'dy'];\n        this.outputShape = [];\n        this.outputShape = inputShape;\n        this.depth = inputShape[3];\n        this.depthRadius = depthRadius;\n        this.bias = bias;\n        this.alpha = alpha;\n        this.beta = beta;\n        this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float result = 0.0;\\n        for (int d = 0; d < \" + this.depth + \"; ++d) {\\n          int depthBegin = int(max(0.0, float(d - \" + depthRadius + \")));\\n          int depthEnd = int(min(float(\" + this.depth + \"),\\n              float(d + \" + depthRadius + \" + 1)));\\n\\n          const int MIN_DEPTH_BEGIN = 0;\\n          const int MAX_DEPTH_END = \" + this.depth + \";\\n\\n          float norm = 0.0;\\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\\n            if (k < depthBegin){\\n              continue;\\n            }\\n            else if (k >= depthBegin && k < depthEnd) {\\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\\n            }\\n            else {\\n              break;\\n            }\\n          }\\n\\n          norm = float(\" + alpha + \") * norm + float(\" + bias + \");\\n\\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\\n            if (k < depthBegin){\\n              continue;\\n            }\\n            else if (k >= depthBegin && k < depthEnd){\\n              float dyi = -2.0 * float(\" + alpha + \")\\n                * float(\" + beta + \")\\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\\n                / norm;\\n              if (k == d) {\\n                dyi += pow(norm, -1.0 * \" + beta + \");\\n              }\\n              if (k == coords[3]) {\\n                dyi *= getDy(b, r, c, d);\\n                result += dyi;\\n              }\\n            }\\n            else {\\n              break;\\n            }\\n          }\\n      }\\n      setOutput(result);\\n      }\\n    \";\n    }\n    return LRNGradProgram;\n}());\nexports.LRNGradProgram = LRNGradProgram;\n"},"sourceMaps":{"js":{"version":3,"file":"lrn_grad_gpu.js","sourceRoot":"","sources":["../../../src/kernels/webgl/lrn_grad_gpu.ts"],"names":[],"mappings":";;AAmBA;IAUE,wBACI,UAAoB,EAAE,WAAmB,EAAE,IAAY,EAAE,KAAa,EACtE,IAAY;QAXhB,kBAAa,GAAG,CAAC,YAAY,EAAE,aAAa,EAAE,IAAI,CAAC,CAAC;QACpD,gBAAW,GAAa,EAAE,CAAC;QAWzB,IAAI,CAAC,WAAW,GAAG,UAAU,CAAC;QAC9B,IAAI,CAAC,KAAK,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;QAC3B,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,QAAQ,GAAG,sNAQU,IAAI,CAAC,KAAK,oEACY,WAAW,qDACtB,IAAI,CAAC,KAAK,oCACzB,WAAW,kGAGC,IAAI,CAAC,KAAK,4aAevB,KAAK,yBAAoB,IAAI,wPAOb,KAAK,mCACpB,IAAI,mLAIY,IAAI,gSAczC,CAAC;IACJ,CAAC;IACH,qBAAC;AAAD,CAAC,AA5ED,IA4EC;AA5EY,wCAAc","sourcesContent":[null]}},"error":null,"hash":"a510a0350508622899267b28687fcb9f","cacheData":{"env":{}}}