{"id":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/crop_and_resize_gpu.js","dependencies":[{"name":"E:\\htr-final\\node_modules\\@tensorflow\\tfjs-core\\dist\\kernels\\webgl\\crop_and_resize_gpu.js.map","includedInParent":true,"mtime":499162500000},{"name":"E:\\htr-final\\package.json","includedInParent":true,"mtime":1603094551417},{"name":"E:\\htr-final\\.babelrc","includedInParent":true,"mtime":1603022514142},{"name":"E:\\htr-final\\node_modules\\@tensorflow\\tfjs-core\\package.json","includedInParent":true,"mtime":1603088140582}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar CropAndResizeProgram = (function () {\n    function CropAndResizeProgram(imageShape, boxShape, cropSize, method, extrapolationValue) {\n        this.variableNames = ['Image', 'Boxes', 'BoxInd'];\n        this.outputShape = [];\n        var batch = imageShape[0], imageHeight = imageShape[1], imageWidth = imageShape[2], depth = imageShape[3];\n        var numBoxes = boxShape[0];\n        var cropHeight = cropSize[0], cropWidth = cropSize[1];\n        this.outputShape = [numBoxes, cropHeight, cropWidth, depth];\n        var methodId = method === 'bilinear' ? 1 : 0;\n        var _a = [imageHeight - 1 + \".0\", imageWidth - 1 + \".0\"], inputHeightFloat = _a[0], inputWidthFloat = _a[1];\n        var _b = cropHeight > 1 ?\n            [\n                \"\" + (imageHeight - 1) / (cropHeight - 1),\n                '(y2-y1) * height_ratio',\n                \"y1*\" + inputHeightFloat + \" + float(y)*(height_scale)\",\n            ] :\n            [\n                '0.0',\n                '0.0',\n                \"0.5 * (y1+y2) * \" + inputHeightFloat,\n            ], heightRatio = _b[0], heightScale = _b[1], inY = _b[2];\n        var _c = cropWidth > 1 ?\n            [\n                \"\" + (imageWidth - 1) / (cropWidth - 1),\n                '(x2-x1) * width_ratio',\n                \"x1*\" + inputWidthFloat + \" + float(x)*(width_scale)\",\n            ] :\n            [\n                '0.0',\n                '0.0',\n                \"0.5 * (x1+x2) * \" + inputWidthFloat,\n            ], widthRatio = _c[0], widthScale = _c[1], inX = _c[2];\n        this.userCode = \"\\n      const float height_ratio = float(\" + heightRatio + \");\\n      const float width_ratio = float(\" + widthRatio + \");\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int y = coords[1];\\n        int x = coords[2];\\n        int d = coords[3];\\n\\n        // get box vals\\n        float y1 = getBoxes(b,0);\\n        float x1 = getBoxes(b,1);\\n        float y2 = getBoxes(b,2);\\n        float x2 = getBoxes(b,3);\\n\\n        // get image in batch index\\n        int bInd = round(getBoxInd(b));\\n        if(bInd < 0 || bInd >= \" + batch + \") {\\n          return;\\n        }\\n\\n        float height_scale = \" + heightScale + \";\\n        float width_scale = \" + widthScale + \";\\n\\n        float in_y = \" + inY + \";\\n        if( in_y < 0.0 || in_y > \" + inputHeightFloat + \" ) {\\n          setOutput(float(\" + extrapolationValue + \"));\\n          return;\\n        }\\n        float in_x = \" + inX + \";\\n        if( in_x < 0.0 || in_x > \" + inputWidthFloat + \" ) {\\n          setOutput(float(\" + extrapolationValue + \"));\\n          return;\\n        }\\n\\n        vec2 sourceFracIndexRC = vec2(in_y,in_x);\\n        if(\" + methodId + \" == 1) {\\n          // Compute the four integer indices.\\n          ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\\n          ivec2 sourceCeilRC = ivec2(ceil(sourceFracIndexRC));\\n\\n          float topLeft = getImage(b, sourceFloorRC.x, sourceFloorRC.y, d);\\n          float bottomLeft = getImage(b, sourceCeilRC.x, sourceFloorRC.y, d);\\n          float topRight = getImage(b, sourceFloorRC.x, sourceCeilRC.y, d);\\n          float bottomRight = getImage(b, sourceCeilRC.x, sourceCeilRC.y, d);\\n\\n          vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\\n\\n          float top = topLeft + (topRight - topLeft) * fracRC.y;\\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\\n          float newValue = top + (bottom - top) * fracRC.x;\\n          setOutput(newValue);\\n        } else {\\n          // Compute the coordinators of nearest neighbor point.\\n          ivec2 sourceNearestRC = ivec2(floor(\\n            sourceFracIndexRC + vec2(0.5,0.5)));\\n          float newValue = getImage(b, sourceNearestRC.x, sourceNearestRC.y, d);\\n          setOutput(newValue);\\n        }\\n      }\\n    \";\n    }\n    return CropAndResizeProgram;\n}());\nexports.CropAndResizeProgram = CropAndResizeProgram;\n"},"sourceMaps":{"js":{"version":3,"file":"crop_and_resize_gpu.js","sourceRoot":"","sources":["../../../src/kernels/webgl/crop_and_resize_gpu.ts"],"names":[],"mappings":";;AAmBA;IAKE,8BACE,UAA4C,EAAE,QAA0B,EACxE,QAA0B,EAAE,MAA8B,EAC1D,kBAA0B;QAP5B,kBAAa,GAAG,CAAC,OAAO,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;QAC7C,gBAAW,GAAa,EAAE,CAAC;QAOlB,IAAA,qBAAK,EAAE,2BAAW,EAAE,0BAAU,EAAE,qBAAK,CAAe;QACpD,IAAA,sBAAQ,CAAc;QACtB,IAAA,wBAAU,EAAE,uBAAS,CAAa;QACzC,IAAI,CAAC,WAAW,GAAG,CAAC,QAAQ,EAAE,UAAU,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;QAC5D,IAAM,QAAQ,GAAG,MAAM,KAAK,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAEzC,IAAA,oDAC2C,EAD1C,wBAAgB,EAAE,uBAAe,CACU;QAE5C,IAAA;;;;;;;;;;aAUH,EAVI,mBAAW,EAAE,mBAAW,EAAE,WAAG,CAUhC;QACE,IAAA;;;;;;;;;;aAUH,EAVI,kBAAU,EAAE,kBAAU,EAAE,WAAG,CAU9B;QAKJ,IAAI,CAAC,QAAQ,GAAG,8CACqB,WAAW,kDACZ,UAAU,kdAgBjB,KAAK,0EAIP,WAAW,uCACZ,UAAU,kCAEjB,GAAG,4CACS,gBAAgB,wCACvB,kBAAkB,gEAGvB,GAAG,4CACS,eAAe,wCACtB,kBAAkB,2GAKjC,QAAQ,umCAwBhB,CAAC;IACJ,CAAC;IACH,2BAAC;AAAD,CAAC,AA3GD,IA2GC;AA3GY,oDAAoB","sourcesContent":[null]}},"error":null,"hash":"b022bd39e1c521efef31d15db754bbf1","cacheData":{"env":{}}}